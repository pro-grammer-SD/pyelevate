use crate::models::{Package, VersionConstraint};
use anyhow::Result;
use chrono::Local;
use std::fs;
use std::path::Path;

pub struct UpgradeManager;

#[derive(Debug, Clone)]
pub struct UpgradeResult {
    pub package_name: String,
    pub old_version: String,
    pub new_version: String,
    pub success: bool,
    pub error: Option<String>,
}

impl UpgradeManager {
    pub fn generate_upgraded_content(
        packages: &[Package],
        original_content: &str,
        only_selected: bool,
    ) -> Result<String> {
        let lines: Vec<&str> = original_content.lines().collect();
        let mut result = Vec::new();

        for line in lines {
            let line_trimmed = line.trim();

            if line_trimmed.is_empty() || line_trimmed.starts_with('#') {
                result.push(line.to_string());
                continue;
            }

            let should_upgrade = packages
                .iter()
                .find(|p| {
                    let line_lower = line.to_lowercase();
                    line_lower.contains(&p.name.to_lowercase())
                })
                .map(|p| {
                    if only_selected {
                        p.selected && p.latest_version.is_some()
                    } else {
                        p.latest_version.is_some()
                    }
                })
                .unwrap_or(false);

            if should_upgrade {
                if let Some(pkg) = packages.iter().find(|p| {
                    let line_lower = line.to_lowercase();
                    line_lower.contains(&p.name.to_lowercase())
                }) {
                    if let Some(latest) = &pkg.latest_version {
                        let upgraded = generate_requirement_line(pkg, latest);
                        result.push(upgraded);
                        continue;
                    }
                }
            }

            result.push(line.to_string());
        }

        Ok(result.join("\n"))
    }

    pub fn create_backup<P: AsRef<Path>>(path: P) -> Result<String> {
        let path = path.as_ref();
        let content = fs::read_to_string(path)?;

        let timestamp = Local::now().format("%Y%m%d_%H%M%S");
        let backup_path = format!(
            "{}.backup.{}",
            path.display(),
            timestamp
        );

        fs::write(&backup_path, content)?;
        Ok(backup_path)
    }

    pub fn write_requirements<P: AsRef<Path>>(path: P, content: &str) -> Result<()> {
        fs::write(path, content)?;
        Ok(())
    }

    pub fn write_lock_file<P: AsRef<Path>>(
        base_path: P,
        packages: &[Package],
    ) -> Result<String> {
        let lock_path = format!("{}.lock", base_path.as_ref().display());
        let mut lines = Vec::new();

        lines.push("# PyElevate Lock File - DO NOT EDIT MANUALLY".to_string());
        lines.push("# This file is automatically generated".to_string());
        lines.push(format!(
            "# Generated at {}",
            Local::now().format("%Y-%m-%d %H:%M:%S UTC")
        ));
        lines.push(String::new());

        for pkg in packages {
            if let Some(latest) = &pkg.latest_version {
                lines.push(format!(
                    "{}{}=={}",
                    pkg.name,
                    if pkg.extras.is_empty() {
                        String::new()
                    } else {
                        format!("[{}]", pkg.extras.join(","))
                    },
                    latest
                ));
            } else {
                lines.push(format!(
                    "{}{}=={}",
                    pkg.name,
                    if pkg.extras.is_empty() {
                        String::new()
                    } else {
                        format!("[{}]", pkg.extras.join(","))
                    },
                    pkg.current_version
                ));
            }
        }

        fs::write(&lock_path, lines.join("\n"))?;
        Ok(lock_path)
    }

    pub fn calculate_upgrade_results(
        packages: &[Package],
        only_selected: bool,
    ) -> Vec<UpgradeResult> {
        packages
            .iter()
            .filter(|p| {
                if only_selected {
                    p.selected && p.latest_version.is_some()
                } else {
                    p.latest_version.is_some()
                }
            })
            .map(|p| UpgradeResult {
                package_name: p.name.clone(),
                old_version: p.current_version.clone(),
                new_version: p.latest_version.clone().unwrap_or_default(),
                success: true,
                error: None,
            })
            .collect()
    }
}

fn generate_requirement_line(pkg: &Package, new_version: &str) -> String {
    let extras_str = if pkg.extras.is_empty() {
        String::new()
    } else {
        format!("[{}]", pkg.extras.join(","))
    };

    match &pkg.constraint {
        VersionConstraint::Pinned(_) => {
            format!("{}{}=={}", pkg.name, extras_str, new_version)
        }
        VersionConstraint::GreaterEqual(old) => {
            format!(
                "{}{}>={}  # upgraded from {}",
                pkg.name, extras_str, new_version, old
            )
        }
        VersionConstraint::Compatible(_) => {
            format!("{}{}~={}", pkg.name, extras_str, new_version)
        }
        VersionConstraint::Range(_, _) => {
            format!("{}{}=={}", pkg.name, extras_str, new_version)
        }
        VersionConstraint::Less(_) => {
            format!("{}{}=={}", pkg.name, extras_str, new_version)
        }
        VersionConstraint::Unspecified => {
            format!("{}{}=={}", pkg.name, extras_str, new_version)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{DependencySource, VersionStatus, SecurityStatus};

    #[test]
    fn test_generate_requirement_line() {
        let pkg = Package {
            name: "requests".to_string(),
            current_version: "2.28.0".to_string(),
            latest_version: Some("2.28.1".to_string()),
            status: VersionStatus::Patch,
            selected: true,
            extras: vec![],
            constraint: VersionConstraint::Pinned("2.28.0".to_string()),
            error: None,
            source: DependencySource::PyPI,
            security_status: SecurityStatus::Safe,
            changelog: None,
            popularity: None,
            dependencies: vec![],
        };

        let line = generate_requirement_line(&pkg, "2.28.1");
        assert_eq!(line, "requests==2.28.1");
    }

    #[test]
    fn test_generate_requirement_line_with_extras() {
        let pkg = Package {
            name: "requests".to_string(),
            current_version: "2.28.0".to_string(),
            latest_version: Some("2.28.1".to_string()),
            status: VersionStatus::Patch,
            selected: true,
            extras: vec!["security".to_string(), "socks".to_string()],
            constraint: VersionConstraint::Pinned("2.28.0".to_string()),
            error: None,
            source: DependencySource::PyPI,
            security_status: SecurityStatus::Safe,
            changelog: None,
            popularity: None,
            dependencies: vec![],
        };

        let line = generate_requirement_line(&pkg, "2.28.1");
        assert!(line.contains("requests[security,socks]==2.28.1"));
    }
}
